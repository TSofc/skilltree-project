<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Skill Tree Interativa</title>
  <style>
    body { background: #191a24; margin: 0; font-family: Arial, sans-serif; overflow: hidden;}
    #tree-canvas { display: block; margin: 0 auto; background: none;}
    .xp-bar-container, .hud, .zoom-label, .btn-mira, .skill-window, .confirm-modal, .btn-demo-jp {position: absolute; z-index: 2;}
    .xp-bar-container {top: 40px; right: 60px; width: 340px; background: #222a; border-radius: 14px; padding: 18px 24px;}
    .xp-label {font-size: 18px; color: #fff; margin-bottom: 12px;}
    .xp-bar-outer {background: #282f42; border-radius: 8px; height: 28px; position: relative; width: 100%; margin-bottom: 5px; overflow: hidden; border: 1px solid #202020;}
    .xp-bar-inner {background: linear-gradient(90deg, #3fcdff 60%, #2affad 100%); height: 100%; border-radius: 8px; transition: width 0.4s cubic-bezier(.28,.67,.44,1);}
    .xp-bar-info {font-size: 15px; color: #e2e3db; position: absolute; width: 100%; text-align: center; top: 5px; left: 0;}
    .hud {left:40px;top:40px; background:#2226; border-radius:12px; padding:14px 30px; color:#fff; font-size:16px;}
    .btn-mira {bottom:40px; right:40px; background:#343856; border:2px solid #1e2231; border-radius:50%; width:56px; height:56px; cursor:pointer; display:flex; align-items:center; justify-content:center; font-size:20px; color: #fff; transition: background 0.2s;}
    .btn-mira:hover {background: #4950a0;}
    .zoom-label {bottom:105px; right:50px; background:#20202a; border-radius:6px; padding:6px 12px; color:#aaa;}
    .skill-window {
      min-width: 340px; max-width: 380px; display:none;
      background: rgba(34,50,93,0.68); color: #fff; padding: 32px 38px; border-radius: 18px;
      border: 1.2px solid #888; box-shadow: none;
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); z-index: 99;
    }
    .btn-close {position:absolute; top:16px; right:22px; border:none; background:none; color:#f44; font-size:28px; cursor:pointer;}
    .btn-close:disabled {opacity: 0.45; cursor: not-allowed;}
    .btn-unlock {margin-top:20px; padding:10px 32px; background:#15f963; color:#000; border:none; border-radius:8px; cursor:pointer; font-size:1.11em; font-weight:600;}
    .btn-unlock:disabled {background:#666; color:#222; cursor:not-allowed;}
    .jp-green {color:#00ff8a; font-weight:bold;}
    .habilidade-ok {color: #29ff77; font-weight: bold; font-size:1.2em;}
    .msg-central { display:flex; align-items:center; justify-content:center; height:140px; font-size:1.6em; color:#fff; text-align:center; }
    .desc-efeito {margin-top: 14px;} .desc-efeito b {font-weight:bold;}
    .desc-efeito em, .desc-efeito i {font-style:italic;}
    .confirm-modal {
      display: none; background: rgba(34,50,93,0.68); color: #fff; left: 50%; top: 50%; transform: translate(-50%, -50%);
      min-width: 320px; min-height: 120px;
      border-radius: 18px; padding: 34px 44px; text-align:center; z-index: 101;
      border: 1.2px solid #888; box-shadow: none;
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
    }
    .confirm-title {font-size: 22px; margin-bottom:10px;}
    .confirm-btns {margin-top:26px;}
    .confirm-btn { padding: 9px 34px; font-size:1.07em; font-weight:600; border:none; border-radius:8px; margin: 0 14px; cursor:pointer; transition: background .18s;}
    .btn-confirm { background: #29ff77; color:#083520;}
    .btn-confirm:hover { background: #1dcc57;}
    .btn-cancel { background: #ff474a; color:#fff;}
    .btn-cancel:hover { background: #c72a2d;}
    .btn-demo-jp {
      left:40px; bottom:40px; background:#0fba5b; color:#fff; border:none; border-radius:9px; padding:15px 28px; font-size:17px;
      font-weight:bold; box-shadow: 0 2px 10px #0009; cursor:pointer; z-index:100;
      transition: background .16s;
    }
    .btn-demo-jp:hover { background: #15f963; color: #222;}
  </style>
</head>
<body>
<canvas id="tree-canvas" width="1800" height="1000"></canvas>
  <div class="xp-bar-container">
    <div class="xp-label">N√≠vel <span id="level">5</span></div>
    <div class="xp-bar-outer"><div class="xp-bar-inner" id="xpBarInner"></div><div class="xp-bar-info" id="xpInfo"></div></div>
  </div>
  <div class="hud">Job Points: <span id="jobpoints">10</span></div>
  <div class="zoom-label" id="zoomLabel">Zoom: 100%</div>
  <button class="btn-mira" id="btnMira" title="Centralizar"><b>üéØ</b></button>
  <button class="btn-demo-jp" id="demoJP">+10 JP</button>
  <div class="skill-window" id="skillWindow" style="display:none;">
    <button id="btnCloseSkill" class="btn-close">√ó</button>
    <h3 id="skillTitle"></h3>
    <span class="jp-green" id="skillJP"></span>
    <div id="skillLinha" style="margin:14px 0; border-bottom: 1px solid #3ad2cc88;"></div>
    <div id="skillDesc" style="margin-bottom:14px;"></div>
    <div id="skillLearned" class="habilidade-ok"></div>
    <div id="msgCentral" class="msg-central" style="display:none;"></div>
    <button id="btnUnlock" class="btn-unlock">Desbloquear</button>
  </div>
  <div class="confirm-modal" id="confirmModal">
    <div class="confirm-title" id="confirmTitle">Deseja aprender esta habilidade?</div>
    <div id="confirmText" style="margin-bottom:8px;"></div>
    <div class="confirm-btns">
      <button class="confirm-btn btn-confirm" id="btnYes">Confirmar</button>
      <button class="confirm-btn btn-cancel" id="btnNo">Cancelar</button>
    </div>
  </div>
<script>
const canvas = document.getElementById('tree-canvas');
const ctx = canvas.getContext('2d');
let zoom = 1.0, zoomTarget = 1.0;
let dragging = false, dragStart = {x:0, y:0}, offsetStart = {x:0, y:0};
let dragBlocked = false;
let interactionBlocked = false;
let confirmationOpen = false;
let nodeDragging = null;
let nodeDragOffset = {wx:0, wy:0};

const CM_PIXELS = 37.8;
const MAIN_RADIUS = 85, SKILL_RADIUS = 44;
const LINKLEN = 10 * CM_PIXELS;
const SUBLEN = 170;
const ANGLE = 25 * Math.PI/180;
let offset = {x: canvas.width/2, y: canvas.height/2};
const MINI_Y = LINKLEN + SUBLEN*Math.cos(ANGLE) + 2 * SKILL_RADIUS + 70;

const NODES = [
  { id: 1, name: "Rise of Jogador", jp:5, desc: "N√≥ central da √°rvore de habilidades.", x: 0, y: 0, radius: MAIN_RADIUS, parent: null },
  { id: 2, name: "Uma Nova Jornada", jp:5, desc: "<b>Descri√ß√£o:</b> Come√ßando sua jornada como um amante dos alimentos, voc√™ passa a entender melhor como eles s√£o feitos, reconhece os sabores e aromas e com isso consegue determinar o que √© mais nutritivo para voc√™!<br><br><b>Efeito:</b> <em>Todos os alimentos consumidos por voc√™, que recuperam fome e sede, ir√£o recuperar 10% a mais que o normal.</em>", x: 0, y: LINKLEN, radius: SKILL_RADIUS, parent: 1, image: "https://i.imgur.com/KEn1dNY.jpeg" },
  { id: 3, name: "Chef Pok√©mon", jp:3, desc: "<b>Descri√ß√£o:</b> Este √© o ponto em que voc√™ decidiu dedicar a sua especialidade em cozinha para os t√£o amados Pok√©mons! A partir de agora suas receitas se voltar√£o para o mundo dos monstrinhos onde voc√™ vai dominar a arte de cozinhar e conhecer o paladar dos Pok√©mons!<br><br><b>Efeito:</b> <em>Permite criar receitas especiais para Pok√©mons.</em>", x: -SUBLEN*Math.sin(ANGLE), y: LINKLEN + SUBLEN*Math.cos(ANGLE), radius: SKILL_RADIUS, parent: 2, image: "https://i.imgur.com/zmTGk6p.jpeg" },
  { id: 4, name: "Chef Treinador", jp:3, desc: "<b>Descri√ß√£o:</b> Voc√™ optou por continuar sua jornada culin√°ria voltada para os gostos humanos! Agora a √°rdua estrada de agradar o paladar dos treinadores ser√° sua! Prepare-se para enfrentar desafios incr√≠veis e se tornar o Chef mais amado dos treinadores!<br><br><b>Efeito:</b> <em>Permite criar receitas especiais para humanos.</em>", x:  SUBLEN*Math.sin(ANGLE), y: LINKLEN + SUBLEN*Math.cos(ANGLE), radius: SKILL_RADIUS, parent: 2, image: "https://i.imgur.com/LS6FNHn.jpeg" },
  { id: 5, name: "Lava Cookie", jp:10, desc: "<b>Descri√ß√£o:</b> Dizem que a melhor medicina √© a natural e voc√™ como acredita fielmente nisso! Ap√≥s muito tempo de estudos voc√™ descobriu uma receita antiga de biscoitos que eram feitos em uma ilha de fogo. Por conta da temperatura local eles sempre sa√≠am do forno quentinhos e prontos para comer. O sabor era t√£o bom que os Pok√©mons sentiam-se revigorados no mesmo instante.<br><br><b>Ingredientes:</b><br>‚Ä¢ A√ß√∫car<br>‚Ä¢ Carv√£o<br>‚Ä¢ Persim Berry<br><br><b>Efeito:</b> <em>Cura qualquer um dos problemas de status.</em>", x: -SUBLEN*Math.sin(ANGLE), y: MINI_Y, radius: SKILL_RADIUS/2, parent: 3, image: "https://i.imgur.com/8t85fxW.png" },
  { id: 6, name: "Berrie Juice", jp: 12, desc: "<b>Descri√ß√£o:</b> Assim como os seres humanos adoram um suco proveniente das frutas cultivadas, n√£o poderia ser diferente com os Pok√©mons. Voc√™ como cozinheiro aprendeu a fazer esta deliciosa receita e al√©m de trazer felicidade aos Pok√©mons, dizem que as frutas utilizadas possuem capacidade de restaurar os ferimentos deles!<br><br><b>Ingredientes:</b><br>‚Ä¢ √Ågua<br>‚Ä¢ Petaya Berry<br>‚Ä¢ Liechi Berry<br><br><b>Efeito:</b> <em>Recupera 20 de HP e aumenta felicidade em 5 pontos.</em>", x: -SUBLEN*Math.sin(ANGLE)-120, y: MINI_Y, radius: SKILL_RADIUS/2, parent: 3, image: "https://i.imgur.com/GY4huWg.png" },
  { id: 7, name: "Shoal Salt", jp: 10, desc: "<b>Descri√ß√£o:</b> Este p√≥ proveniente de conchas pode ser muito √∫til em algumas receitas, mas n√£o √© f√°cil obt√™-lo! Para conseguir esta esp√©cie de sal marinho √© preciso moer uma conha atrav√©s de um processo que demora algum tempo.<br><br><b>Ingredientes:</b><br>‚Ä¢ Shoal Shell<br><br><b>Efeito:</b> <em>Produz o Item ‚ÄúShoal Salt‚Äù</em>", x: -SUBLEN*Math.sin(ANGLE)-240, y: MINI_Y, radius: SKILL_RADIUS/2, parent: 3, image: "https://i.imgur.com/R2Vi7Ud.png" },
  { id: 8, name: "Sais Minerais", jp: 10, desc: "<b>Descri√ß√£o:</b> Sabemos que as conchas s√£o calcifica√ß√µes de algumas mat√©rias. Como o fundo do mar √© antigo e ret√©m consigo muitos sedimentos na areia, algumas partes dele acabam incrustando na concha no processo de cria√ß√£o, trazendo os minerais necess√°rios para este sal. Quando a concha √© mo√≠da e transformada no Shoal Salt, ele passa por um processo de refino no qual se obt√©m este material.<br><br><b>Ingredientes:</b><br>‚Ä¢ Shoal Salt<br><br><b>Efeito:</b> <em>Produz o Item ‚ÄúSais Minerais‚Äù</em>", x: -SUBLEN*Math.sin(ANGLE)-240, y: MINI_Y+90, radius: SKILL_RADIUS/2, parent: 7, image: "https://i.imgur.com/xINvX1m.png" },
  { id: 9, name: "Mini N√≥ 1", jp: 5, desc: "<b>Descri√ß√£o:</b> Mini n√≥ 1 derivado do Berrie Juice.<br><br>Efeito: Exemplo.", x: -SUBLEN*Math.sin(ANGLE)-70, y: MINI_Y+170, radius: SKILL_RADIUS/2, parent: 6, image: "https://i.imgur.com/xINvX1m.png" },
  { id: 10, name: "Mini N√≥ 2", jp: 5, desc: "<b>Descri√ß√£o:</b> Mini n√≥ 2 derivado do Berrie Juice.<br><br>Efeito: Exemplo.", x: -SUBLEN*Math.sin(ANGLE)-170, y: MINI_Y+170, radius: SKILL_RADIUS/2, parent: 6, image: "https://i.imgur.com/xINvX1m.png" }
];

let unlocked = [1];
let jobPoints = 10, level = 5, xp = 100, xpmax = 195;
let hoveredNode = null;
let zoomNodeId = null;
let zoomNodeAnim = 0;
let popupAnim = 0;
let popupTarget = 0;
let popupScaleFinal = 2;
let nodeToUnlock = null;
let images = {};
function loadSkillImages(callback) {
  let count = 0, loaded = 0;
  for (const node of NODES) {
    if(node.image) {
      count++;
      let img = new Image();
      img.crossOrigin = "anonymous";
      img.src = node.image;
      img.onload = function(){ loaded++; images[node.id]=img; if(loaded==count) callback();}
      img.onerror = function(){ loaded++; images[node.id]=null; if(loaded==count) callback();}
    }
  }
  if(count===0) callback();
}
function areBothUnlocked(a, b) { return unlocked.includes(a) && unlocked.includes(b); }
function updateXPBar() {
  let pct = Math.min(xp/xpmax,1)*100;
  document.getElementById('xpBarInner').style.width = pct+'%';
  document.getElementById('xpInfo').textContent = xp+' / '+xpmax+' XP';
  document.getElementById('level').textContent = level;
}
function addJP(amt){
  jobPoints+=amt;
  document.getElementById('jobpoints').textContent = jobPoints;
}
updateXPBar();
document.getElementById('jobpoints').textContent = jobPoints;
document.getElementById('demoJP').onclick=function() { addJP(10); };
setInterval(function(){
  xp+=33;
  if(xp>=xpmax) {
    xp = xp-xpmax;
    level++;
    xpmax = Math.round(xpmax*1.11)+5;
    document.getElementById('level').textContent = level;
  }
  updateXPBar();
}, 30000);

function worldToScreen(wx, wy) { return { x: wx * zoom + offset.x, y: wy * zoom + offset.y }; }
function screenToWorld(sx, sy) { return { x: (sx - offset.x) / zoom, y: (sy - offset.y) / zoom }; }
function getNodeCenter(node) { return worldToScreen(node.x, node.y); }
function getNodeDrawScale(node) {
  let scale = 1;
  if(zoomNodeId===node.id) scale += zoomNodeAnim*1.0;
  if(hoveredNode===node.id && areBothUnlocked(node.parent||1,node.id)) scale += popupAnim*0.13;
  return scale;
}
function drawLineWithGlow(ax, ay, bx, by, unlockedLink) {
  if(!unlockedLink) {
    ctx.save(); ctx.beginPath(); ctx.moveTo(ax, ay); ctx.lineTo(bx, by);
    ctx.lineWidth = 2.4*zoom; ctx.strokeStyle = "#b3b3b3";
    ctx.globalAlpha = 1; ctx.shadowBlur = 0; ctx.stroke(); ctx.restore(); return;
  }
  const green = "38,255,180";
  let steps = 14, pxlin = 2.4;
  for(let i=0;i<steps;i++){
    ctx.save(); ctx.beginPath(); ctx.moveTo(ax, ay); ctx.lineTo(bx, by);
    let r=i/steps, width=(pxlin+r*24)*zoom;
    ctx.lineWidth=width;
    let alpha=r<0.07?0.78:0.52*Math.max(0,(1-r))*Math.exp(-r*6);
    ctx.strokeStyle=`rgba(${green},${alpha})`;
    ctx.shadowBlur=r<0.10?6:9+r*20; ctx.shadowColor="#26ffb4";
    ctx.globalAlpha=1; ctx.stroke(); ctx.restore();
  }
  ctx.save(); ctx.beginPath(); ctx.moveTo(ax, ay); ctx.lineTo(bx, by);
  ctx.lineWidth=2.1*zoom; ctx.strokeStyle="#fff"; ctx.globalAlpha=1; ctx.shadowBlur=0;
  ctx.stroke(); ctx.restore();
}
function drawCurvedLine(ax, ay, bx, by, unlockedLink, dist=80) {
  const green = "38,255,180";
  let steps = unlockedLink ? 14 : 1;
  let pxlin = 2.4;
  for(let i=0;i<steps;i++){
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    let cx1 = ax - dist*zoom, cy1 = ay + 70*zoom;
    let cx2 = bx - dist*zoom, cy2 = by - 70*zoom;
    ctx.bezierCurveTo(cx1, cy1, cx2, cy2, bx, by);
    if(unlockedLink){
      let r=i/steps, width=(pxlin+r*24)*zoom;
      ctx.lineWidth=width;
      let alpha=r<0.07?0.78:0.52*Math.max(0,(1-r))*Math.exp(-r*6);
      ctx.strokeStyle=`rgba(${green},${alpha})`;
      ctx.shadowBlur=r<0.10?6:9+r*20; ctx.shadowColor="#26ffb4";
      ctx.globalAlpha=1;
    }else{
      ctx.lineWidth=2.2*zoom; ctx.strokeStyle="#b3b3b3"; ctx.shadowBlur=0; ctx.globalAlpha=1;
    }
    ctx.stroke();
    ctx.restore();
  }
  if(unlockedLink){
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    let cx1 = ax - dist*zoom, cy1 = ay + 70*zoom;
    let cx2 = bx - dist*zoom, cy2 = by - 70*zoom;
    ctx.bezierCurveTo(cx1, cy1, cx2, cy2, bx, by);
    ctx.lineWidth=2.1*zoom; ctx.strokeStyle="#fff"; ctx.globalAlpha=1; ctx.shadowBlur=0;
    ctx.stroke();
    ctx.restore();
  }
}
function drawTracheaCurve(ax, ay, bx, by, unlockedLink) {
  const green = "38,255,180";
  let steps = unlockedLink ? 14 : 1;
  let pxlin = 2.4;
  for(let i=0;i<steps;i++){
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.bezierCurveTo(ax, ay+70, bx, by-40, bx, by);
    if(unlockedLink){
      let r=i/steps, width=(pxlin+r*24)*zoom;
      ctx.lineWidth=width;
      let alpha=r<0.07?0.78:0.52*Math.max(0,(1-r))*Math.exp(-r*6);
      ctx.strokeStyle=`rgba(${green},${alpha})`;
      ctx.shadowBlur=r<0.10?6:9+r*20; ctx.shadowColor="#26ffb4";
      ctx.globalAlpha=1;
    }else{
      ctx.lineWidth=2.2*zoom; ctx.strokeStyle="#b3b3b3"; ctx.shadowBlur=0; ctx.globalAlpha=1;
    }
    ctx.stroke();
    ctx.restore();
  }
  if(unlockedLink){
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.bezierCurveTo(ax, ay+70, bx, by-40, bx, by);
    ctx.lineWidth=2.1*zoom; ctx.strokeStyle="#fff"; ctx.globalAlpha=1; ctx.shadowBlur=0;
    ctx.stroke();
    ctx.restore();
  }
}

function drawTree() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  let mainNode = NODES[0];
  let baseSize = mainNode.radius*zoom;
  let size = baseSize;
  let mainPos = getNodeCenter(mainNode);
  let maxGlow = size+330;
  let grad = ctx.createRadialGradient(mainPos.x,mainPos.y,size,mainPos.x,mainPos.y,maxGlow);
  grad.addColorStop(0,"rgba(255,255,255,0.23)");
  grad.addColorStop(0.11,"rgba(255,255,255,0.13)");
  grad.addColorStop(0.24,"rgba(255,255,255,0.08)");
  grad.addColorStop(0.37,"rgba(255,255,255,0.04)");
  grad.addColorStop(0.52,"rgba(255,255,255,0.016)");
  grad.addColorStop(0.7,"rgba(255,255,255,0.006)");
  grad.addColorStop(1,"rgba(255,255,255,0)");
  ctx.save(); ctx.beginPath(); ctx.arc(mainPos.x,mainPos.y,maxGlow,0,2*Math.PI);
  ctx.fillStyle=grad; ctx.fill(); ctx.restore();

  let a1 = {x: mainPos.x, y: mainPos.y + mainNode.radius * zoom * getNodeDrawScale(mainNode)};
  drawLineWithGlow(a1.x,a1.y,getNodeCenter(NODES[1]).x,getNodeCenter(NODES[1]).y,areBothUnlocked(1,2));
  
  for(let i=2; i<NODES.length; i++){
    if(NODES[i].parent === 7 && NODES[i].id === 8){
      let from = getNodeCenter(NODES[6]);
      let to = getNodeCenter(NODES[7]);
      drawLineWithGlow(from.x, from.y+NODES[6].radius*zoom, to.x, to.y-NODES[7].radius*zoom, areBothUnlocked(7,8));
    } else
    if(NODES[i].parent === 3 && NODES[i].id===6){
      let from = getNodeCenter(NODES[2]);
      let to = getNodeCenter(NODES[5]);
      drawCurvedLine(from.x,from.y+SKILL_RADIUS*zoom, to.x, to.y, areBothUnlocked(3,6), 80);
    }else if(NODES[i].parent === 3 && NODES[i].id===7){
      let from = getNodeCenter(NODES[2]);
      let to = getNodeCenter(NODES[6]);
      drawCurvedLine(from.x,from.y+SKILL_RADIUS*zoom, to.x, to.y, areBothUnlocked(3,7), 160);
    }else if (NODES[i].parent === 6 && (NODES[i].id === 9 || NODES[i].id === 10)) {
      // traqueia
    } else {
      let parentNode = NODES.find(n => n.id === NODES[i].parent);
      if (parentNode && !(NODES[i].parent === 7 && NODES[i].id === 8)) {
        drawLineWithGlow(getNodeCenter(parentNode).x, getNodeCenter(parentNode).y, getNodeCenter(NODES[i]).x, getNodeCenter(NODES[i]).y, areBothUnlocked(parentNode.id, NODES[i].id));
      }
    }
  }
  // traqueias INDIVIDUAIS Y
  let berrie = NODES[5], mn1 = NODES[8], mn2 = NODES[9];
  if(berrie && mn1){
    let cfrom = getNodeCenter(berrie), c1 = getNodeCenter(mn1);
    drawTracheaCurve(
      cfrom.x, cfrom.y + berrie.radius*zoom,
      c1.x, c1.y-mn1.radius*zoom,
      areBothUnlocked(berrie.id, mn1.id)
    );
  }
  if(berrie && mn2){
    let cfrom = getNodeCenter(berrie), c2 = getNodeCenter(mn2);
    drawTracheaCurve(
      cfrom.x, cfrom.y + berrie.radius*zoom,
      c2.x, c2.y-mn2.radius*zoom,
      areBothUnlocked(berrie.id, mn2.id)
    );
  }
  for(const n of NODES){
    let nodeZoom = getNodeDrawScale(n);
    const pos=getNodeCenter(n);
    let nodeRadius=n.radius*zoom*nodeZoom;
    ctx.save();
    ctx.beginPath();
    ctx.arc(pos.x,pos.y,nodeRadius,0,2*Math.PI);
    if(n.id===1){
      ctx.fillStyle="#fff";
      ctx.shadowColor="rgba(255,255,255,0.45)";
      ctx.shadowBlur=38*nodeZoom; ctx.lineWidth=0; ctx.strokeStyle="#fff";
    }else{
      ctx.fillStyle=unlocked.includes(n.id)?'#fff':'#23232d';
      ctx.shadowColor=unlocked.includes(n.id)?"#2affad":'#0004';
      ctx.shadowBlur=unlocked.includes(n.id)?(42*zoom*nodeZoom):0;
      ctx.lineWidth=unlocked.includes(n.id)?(2*zoom*nodeZoom):(4*zoom*nodeZoom);
      ctx.strokeStyle=unlocked.includes(n.id)?"#2affad":'#444';
    }
    ctx.fill();
    if(n.id!==1) ctx.stroke();
    ctx.shadowBlur=0;
    if(n.name && n.id===1){
      ctx.fillStyle='#282856';
      ctx.font=`500 ${22*zoom*nodeZoom}px "Segoe UI",Arial,sans-serif`;
      ctx.textAlign='center';
      ctx.fillText(n.name,pos.x,pos.y+10*zoom*nodeZoom);
    }
    if(n.image && images[n.id]){
      ctx.save();
      ctx.beginPath();
      ctx.arc(pos.x,pos.y,nodeRadius-4,0,2*Math.PI);
      ctx.clip();
      const img=images[n.id];
      const s=Math.min(img.width,img.height);
      ctx.drawImage(img, (img.width-s)/2, (img.height-s)/2, s, s, pos.x-nodeRadius+4, pos.y-nodeRadius+4, (nodeRadius-4)*2, (nodeRadius-4)*2);
      ctx.restore();
    }
    ctx.restore();
  }
}
loadSkillImages(drawTree);
function lerp(a,b,t){return a+(b-a)*t;}
function animatePopup() {
  const t=0.13;
  popupAnim=lerp(popupAnim,popupTarget,t);
  if(Math.abs(popupTarget-popupAnim)<0.001)popupAnim=popupTarget;
  zoomNodeAnim=lerp(zoomNodeAnim,zoomNodeId?1:0,t);
  zoom=lerp(zoom,zoomTarget,0.23);
  if(Math.abs(zoom-zoomTarget)<0.0001)zoom=zoomTarget;
  document.getElementById('zoomLabel').textContent='Zoom: '+Math.round(zoom*100)+'%';
  drawTree();
  requestAnimationFrame(animatePopup);
}
animatePopup();

canvas.addEventListener('mousedown',e=>{
  if(interactionBlocked) return;
  if(e.button!==0) return;
  let found=null;
  for(const n of NODES){
    const pos=getNodeCenter(n);
    let nodeZoom=getNodeDrawScale(n);
    let size=(n.radius*zoom*nodeZoom)+10;
    if(Math.hypot(pos.x-e.offsetX,pos.y-e.offsetY)<=size){
      found=n;
      break;
    }
  }
  if(found && !zoomNodeId){
    nodeDragging = found;
    const world = screenToWorld(e.offsetX, e.offsetY);
    nodeDragOffset.wx = world.x - found.x;
    nodeDragOffset.wy = world.y - found.y;
    dragging = false;
    dragBlocked = true;
    return;
  }
  if(!dragBlocked){
    dragging=true; dragStart={x:e.clientX,y:e.clientY}; offsetStart={...offset};
  }
});

canvas.addEventListener('mousemove',e=>{
  if(interactionBlocked) return;
  if(nodeDragging){
    const world = screenToWorld(e.offsetX, e.offsetY);
    nodeDragging.x = world.x - nodeDragOffset.wx;
    nodeDragging.y = world.y - nodeDragOffset.wy;
    drawTree();
    return;
  }
  let found=null;
  for(const n of NODES){
    const pos=getNodeCenter(n);
    let nodeZoom=getNodeDrawScale(n);
    let size=(n.radius*zoom*nodeZoom)+10;
    if(Math.hypot(pos.x-e.offsetX,pos.y-e.offsetY)<=size){found=n.id;break;}
  }
  hoveredNode=found;
  popupTarget=!!hoveredNode;
  if(dragging && !nodeDragging){
    offset.x=offsetStart.x+(e.clientX-dragStart.x);
    offset.y=offsetStart.y+(e.clientY-dragStart.y);
    drawTree();
  }
});

window.addEventListener('mouseup',()=>{
  if(nodeDragging){
    nodeDragging=null;
    dragBlocked=false;
    drawTree();
  }
  dragging=false;
});

canvas.addEventListener('mouseleave',()=>{
  if(nodeDragging){
    nodeDragging=null;
    dragBlocked=false;
    drawTree();
  }
  dragging=false;
});

canvas.addEventListener('wheel',e=>{
  if(interactionBlocked) return;
  e.preventDefault();
  const dz=(e.deltaY>0)?0.9:1.1;
  zoomTarget *= dz;
  zoomTarget=Math.min(Math.max(zoomTarget,0.35),2.5);
});

canvas.addEventListener('click',e=>{
  if(interactionBlocked) return;
  if(nodeDragging) return;
  for(const n of NODES){
    const pos=getNodeCenter(n);
    let nodeZoom=getNodeDrawScale(n);
    let size=n.radius*zoom*nodeZoom;
    if(Math.hypot(pos.x-e.offsetX,pos.y-e.offsetY)<=size){
      zoomNodeId=n.id;
      openSkillWindow(n,pos);
      return;
    }
  }
});

function canUnlock(id) {
  const node = NODES.find(x=>x.id===id);
  if (!node.parent) return false;
  return unlocked.includes(node.parent) && !unlocked.includes(id) && jobPoints>=node.jp;
}
function haveLearned(id) { return unlocked.includes(id);}
function centralizaNoZoomado(noid, forcarCentroPrincipal=false){
  if(interactionBlocked) return;
  const n=NODES.find(a=>a.id===noid);
  zoomTarget=1.0;
  offset.x = canvas.width/2-(n.x*zoomTarget);
  offset.y = canvas.height/2-(n.y*zoomTarget);
  drawTree();
  document.getElementById('zoomLabel').textContent='Zoom: 100%';
}
document.getElementById('btnMira').onclick = ()=>{ if(!interactionBlocked) centralizaNoZoomado(1, true); };
function openSkillWindow(node,pos){
  dragBlocked=true;
  interactionBlocked=true;
  confirmationOpen=false;
  zoomNodeId=node.id;
  const win = document.getElementById('skillWindow');
  win.style.display='block';
  document.getElementById('skillTitle').style.display='block';
  document.getElementById('skillTitle').textContent=node.name||"Skill";
  document.getElementById('skillJP').style.display='inline';
  document.getElementById('skillJP').textContent=(node.jp||"") + " JP";
  document.getElementById('skillDesc').style.display='block';
  document.getElementById('skillDesc').innerHTML=node.desc;
  document.getElementById('skillLinha').style.display='block';
  document.getElementById('msgCentral').style.display='none';
  const btn=document.getElementById('btnUnlock');
  let learned = haveLearned(node.id);
  let canLearn = canUnlock(node.id);
  document.getElementById('skillLearned').style.display=learned?"block":"none";
  document.getElementById('skillLearned').textContent=learned?"Habilidade j√° aprendida!":"";
  btn.style.display=learned?"none":"inline-block";
  btn.disabled = !canLearn;
  btn.onclick=()=>{
    nodeToUnlock=node.id;
    document.getElementById('confirmModal').style.display='block';
    interactionBlocked=true;
    confirmationOpen=true;
    document.getElementById('btnCloseSkill').disabled = true;
    document.getElementById('confirmText').textContent = `Deseja aprender "${node.name}" gastando ${node.jp} JP?`;
  };
  let scale=popupScaleFinal;
  let cx=getNodeCenter(node).x;
  let cy=getNodeCenter(node).y;
  let w=400,h=240;
  let left=Math.max(Math.min(cx+node.radius*zoom*scale+42,window.innerWidth-w-24),0);
  let top=Math.max(60,cy-h/2);
  win.style.left=left+'px';
  win.style.top=top+'px';
}
document.getElementById('btnCloseSkill').onclick = function() {
  if(confirmationOpen) return;
  closeSkillWindow();
};
function closeSkillWindow(){
  dragBlocked=false;
  interactionBlocked=false;
  confirmationOpen=false;
  document.getElementById('skillWindow').style.display='none';
  zoomNodeId=null;
  zoomNodeAnim=0;
  document.getElementById('btnCloseSkill').disabled = false;
  drawTree();
}
document.getElementById('btnYes').onclick=()=>{
  document.getElementById('confirmModal').style.display='none';
  interactionBlocked=false;
  confirmationOpen=false;
  document.getElementById('btnCloseSkill').disabled = false;
  if(nodeToUnlock){
    unlockNode(nodeToUnlock);
    closeSkillWindow();
    nodeToUnlock=null;
    drawTree();
  }
}
document.getElementById('btnNo').onclick=()=>{
  document.getElementById('confirmModal').style.display='none';
  interactionBlocked=false;
  confirmationOpen=false;
  document.getElementById('btnCloseSkill').disabled = false;
  nodeToUnlock=null;
};
function unlockNode(id){
  const node = NODES.find(n => n.id === id);
  if(canUnlock(id) && node && node.jp > 0){
    unlocked.push(id);
    jobPoints -= node.jp;
    if(jobPoints < 0) jobPoints = 0;
    document.getElementById('jobpoints').textContent = jobPoints;
  }
}
</script>
</body>
</html>
